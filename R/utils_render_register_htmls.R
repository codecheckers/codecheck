#' Dynamically generates a html_document.yml with the full paths to the index header, prefix 
#' and postfix.html files. 
#' 
#' @param output_dir The output directory where the html_document needs to be saved.
generate_html_document_yml <- function(output_dir) {
  output_dir <- paste0(getwd(), "/", output_dir)

  yaml_content <- sprintf(
    "# DO NOT EDIT THIS FILE MANUALLY
    html_document:
      includes:
        in_header: '%sindex_header.html'
        before_body: '%sindex_prefix.html'
        after_body: '%sindex_postfix.html'
      mathjax: null
      highlight: null
      self_contained: false
      lib_dir: libs",
    output_dir, output_dir, output_dir
  )
  writeLines(yaml_content, paste0(output_dir, "html_document.yml"))
}

#' Dynamically generates the index_postfix.html from a template file
#'
#' @param output_dir The output directory
#' @param filter The filter name
#' @param table_details List containing details such as the table name, subcat name.
#' @importFrom whisker whisker.render
create_index_postfix_html <- function(output_dir, filter, table_details){

  if (table_details[["is_reg_table"]]){
    postfix_template <- readLines(CONFIG$TEMPLATE_DIR[["reg"]][["postfix"]], warn = FALSE)
    # Render the template with the correct hrefs
    hrefs <- generate_html_postfix_hrefs_reg(filter, table_details)
  }

  # Generating the postfix for non-register table pages (e.g. list of venues and codecheckers)
  else{
    postfix_template <- readLines(CONFIG$TEMPLATE_DIR[["non_reg"]][["postfix"]], warn = FALSE)
    hrefs <- generate_html_postfix_hrefs_non_reg(filter, table_details)
  }

  # Generate footer build info from build metadata
  build_info <- ""
  if (exists("BUILD_METADATA", envir = CONFIG) && !is.null(CONFIG$BUILD_METADATA)) {
    build_info <- generate_footer_build_info(CONFIG$BUILD_METADATA)
  }

  # Add build_info to hrefs for rendering
  hrefs$build_info <- build_info

  output <- whisker.render(postfix_template, hrefs)
  writeLines(output, paste0(output_dir, "index_postfix.html"))
}

#' Dynamically generates the index_prefix.html with navigation header and breadcrumbs
#'
#' @param output_dir The output directory
#' @param filter The filter name
#' @param table_details List containing details such as the table name, subcat name.
create_index_prefix_html <- function(output_dir, filter = NA, table_details = list()){
  # Calculate base path for links
  base_path <- calculate_breadcrumb_base_path(filter, table_details)

  # Generate navigation header (with logo and conditional menu)
  nav_header_html <- generate_navigation_header(filter, base_path, table_details)

  # Generate breadcrumb HTML
  breadcrumb_html <- generate_breadcrumb(filter, table_details, base_path)

  # Combine navigation header and breadcrumbs
  prefix_content <- paste0(
    nav_header_html,
    '<div style="max-width: 1200px; margin: 1rem auto; padding: 0 1rem;">\n',
    breadcrumb_html,
    '\n</div>\n'
  )

  writeLines(prefix_content, paste0(output_dir, "index_prefix.html"))
}

#' Dynamically generates the index_header.html from a template file
#'
#' @param output_dir The output directory
#' @importFrom whisker whisker.render
create_index_header_html <- function(output_dir){
  # Using the index_header_template
  header_template <- readLines(CONFIG$TEMPLATE_DIR[["reg"]][["header"]], warn = FALSE)

  # Generate meta generator content from build metadata
  meta_generator <- ""
  if (exists("BUILD_METADATA", envir = CONFIG) && !is.null(CONFIG$BUILD_METADATA)) {
    meta_generator <- generate_meta_generator_content(CONFIG$BUILD_METADATA)
  }

  # Calculate relative path to docs root based on output_dir depth
  # Count directory levels from docs/ (output_dir includes trailing slash)
  path_components <- strsplit(output_dir, "/")[[1]]
  # Remove empty strings and "docs"
  path_components <- path_components[path_components != "" & path_components != "docs"]
  depth <- length(path_components)

  # Generate relative path (e.g., "../" for depth 1, "../../" for depth 2)
  if (depth == 0) {
    base_path <- ""
  } else {
    base_path <- paste(rep("../", depth), collapse = "")
  }

  # Render the template with meta generator tag and base path
  output <- whisker.render(paste(header_template, collapse = "\n"),
                          list(meta_generator = meta_generator,
                               base_path = base_path))

  writeLines(output, paste0(output_dir, "index_header.html"))
}

#' Generates the hrefs to set in the postfix.html file for the rendering of register tables.
#' 
#' @param filter The filter name
#' @param table_details List containing details such as the table name, subcat name.
#' @return A list with the hrefs
generate_html_postfix_hrefs_reg <- function(filter, table_details) {
  hrefs <- list(
    csv_source_href = generate_href(filter, table_details, "csv_source"),
    searchable_csv_href = generate_href(filter, table_details, "searchable_csv"),
    json_href = generate_href(filter, table_details, "json"),
    md_href = generate_href(filter, table_details, "md")
  )
  return(hrefs)
}

#' Generate full href for for different href types.
#'
#' @param filter The filter name 
#' @param table_details A list containing details needed for the hrefs
#' @param href_type The href type (e.g., 'csv_source', 'searchable_csv', 'json', 'md')
#' @return String representing the full URL to access the specified resource
generate_href <- function(filter, table_details, href_type) {
  # Loading the correct href details from the CONFIG 
  href_details <- CONFIG$HREF_DETAILS[[href_type]]
  
  base_url <- href_details$base_url
  # For the original register
  if (is.na(filter)) {
    return(paste0(base_url, "register", href_details$ext))
  } 

  # Determining if we need to include "/docs" in the href for csvs.
  # This is needed for the case where we have filters
  include_docs_in_href <- href_type %in% c("csv_source", "searchable_csv")
  if (include_docs_in_href){
    base_url <- paste0(base_url, "docs/")
  } 

  # Setting href for filters with subcategories
  if ("subcat" %in% names(table_details)){
    subcat <- table_details[["subcat"]]
    # If subcat is venue type, we pluralize the venue names
    if (subcat %in% names(CONFIG$VENUE_SUBCAT_PLURAL)){
      subcat <- CONFIG$VENUE_SUBCAT_PLURAL[[subcat]]
    }
    return(paste0(base_url, filter, "/", subcat, "/", table_details[["slug_name"]], "/register", href_details$ext))
  }

  # For filters without subcategories
  return(paste0(base_url, filter, "/", table_details[["slug_name"]], "/register", href_details$ext))
}

#' Creates index postfix, prefix and the header
#'
#' @param output_dir The output directory of the section files
#' @param filter The filter name
#' @param table_details List containing details such as the table name, subcat name.
create_index_section_files <- function(output_dir, filter, table_details) {
  create_index_postfix_html(output_dir, filter, table_details)
  create_index_prefix_html(output_dir, filter, table_details)
  create_index_header_html(output_dir)
}

#' Renders html for a single table
#' 
#' This function can be used to render both register and non-register tables
#' @param table The table to render to HTML
#' @param table_details List containing details such as the table name, subcat name.
#' @param filter The filter
render_html <- function(table, table_details, filter){

  # Creating md file from which HTML file is made
  if (table_details[["is_reg_table"]]){
    table_details[["for_html_file"]] <- TRUE
    render_register_md(table, table_details, filter)
  }

  else{
    render_non_register_md(table, table_details, filter)
  }

  output_dir <- table_details[["output_dir"]]
  temp_md_file_path <- paste0(output_dir, "temp.md")

  # Creating the index section files and yml document
  create_index_section_files(output_dir, filter, table_details)
  generate_html_document_yml(output_dir)

  yaml_path <- normalizePath(file.path(getwd(), paste0(output_dir, "html_document.yml")))

  # Render HTML from markdown
  rmarkdown::render(
    input = temp_md_file_path,
    output_file = "index.html",
    output_dir = output_dir,
    output_yaml = yaml_path
  )

  file.remove(temp_md_file_path)

  # For all registered tables besides the original we change the html
  # file so that the path to the libs folder refers to the libs folder "docs/libs".
  # This is done to remove duplicates of "libs" folders.
  if (!is.na(filter)){
    html_file_path <- paste0(output_dir, "index.html")
    edit_html_lib_paths(html_file_path)
    # Deleting the libs folder after changing the html lib path
    unlink(paste0(output_dir, "/libs"), recursive = TRUE)
  }
}

#' Loads a html file and replaces the libs path in the html file to the libs folder in "docs/libs"
#' This is done so all html files can share one libs folder. 
#' 
#' @param html_file_path The path to the html file that needs to be edited.
edit_html_lib_paths <- function(html_file_path) {

  path_components <- strsplit(html_file_path, "/")[[1]]
  # The count of dirs one needs to move up to reach "docs" folder. "-2" is used because both "docs"
  # "index.html" are elements in path_components. 
  count_dir_up <- length(path_components) - 2
  up_dirs_string <- rep("../", count_dir_up)

  # Relative path to the "docs/libs" folder
  path_to_base <- paste0(up_dirs_string, collapse = "")
  relative_libs_dir <- paste0(path_to_base, "libs/")

  # Read the HTML file lines into a vector
  html_lines <- readLines(html_file_path)
  
  # Replace lines containing "=libs/" with the appropriate relative path to "docs/libs"
  edited_lines <- gsub('="libs/', paste0('="', relative_libs_dir), html_lines)
  
  # Write the edited lines back to the file
  writeLines(edited_lines, html_file_path)
}
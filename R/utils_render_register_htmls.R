#' Dynamically generates a html_document.yml with the full paths to the index header, prefix 
#' and postfix.html files. 
#' 
#' @param output_dir The output directory where the html_document needs to be saved.
generate_html_document_yml <- function(output_dir) {
  output_dir <- paste0(getwd(), "/", output_dir)

  yaml_content <- sprintf(
    "# DO NOT EDIT THIS FILE MANUALLY
    html_document:
      includes:
        in_header: '%sindex_header.html'
        before_body: '%sindex_prefix.html'
        after_body: '%sindex_postfix.html'
      mathjax: null
      highlight: null
      self_contained: false
      lib_dir: libs",
    output_dir, output_dir, output_dir
  )
  writeLines(yaml_content, paste0(output_dir, "html_document.yml"))
}

#' Dynamically generates the index_postfix.html from a template file 
#' 
#' @param output_dir The output directory
#' @param filter The filter name
#' @param table_details List containing details such as the table name, subcat name.
#' @importFrom whisker whisker.render
create_index_postfix_html <- function(output_dir, filter, table_details){

  if (table_details[["is_reg_table"]]){
    postfix_template <- readLines(CONFIG$TEMPLATE_DIR[["reg"]][["postfix"]], warn = FALSE)
    # Render the template with the correct hrefs
    hrefs <- generate_html_postfix_hrefs_reg(filter, table_details)
  }

  # Generating the postfix for non-register table pages (e.g. list of venues and codecheckers)
  else{
    postfix_template <- readLines(CONFIG$TEMPLATE_DIR[["non_reg"]][["postfix"]], warn = FALSE)
    hrefs <- generate_html_postfix_hrefs_non_reg(filter, table_details)
  }

  output <- whisker.render(postfix_template, hrefs)
  writeLines(output, paste0(output_dir, "index_postfix.html"))
}

#' Dynamically generates the index_prefix.html from a template file 
#' 
#' @param output_dir The output directory
create_index_prefix_html <- function(output_dir){
  # Using the index_prefix_template
  prefix_template <- readLines(CONFIG$TEMPLATE_DIR[["reg"]][["prefix"]], warn = FALSE)
  writeLines(prefix_template, paste0(output_dir, "index_prefix.html"))
}

#' Dynamically generates the index_header.html from a template file 
#' 
#' @param output_dir The output directory
create_index_header_html <- function(output_dir){
  # Using the index_header_template
  header_template <- readLines(CONFIG$TEMPLATE_DIR[["reg"]][["header"]], warn = FALSE)

  writeLines(header_template, paste0(output_dir, "index_header.html"))
}

#' Generates the hrefs to set in the postfix.html file for the rendering of register tables.
#' 
#' @param filter The filter name
#' @param table_details List containing details such as the table name, subcat name.
#' @return A list with the hrefs
generate_html_postfix_hrefs_reg <- function(filter, table_details) {
  hrefs <- list(
    csv_source_href = generate_href(filter, table_details, "csv_source"),
    searchable_csv_href = generate_href(filter, table_details, "searchable_csv"),
    json_href = generate_href(filter, table_details, "json"),
    md_href = generate_href(filter, table_details, "md")
  )
  return(hrefs)
}

#' Generate full href for for different href types.
#'
#' @param filter The filter name 
#' @param table_details A list containing details needed for the hrefs
#' @param href_type The href type (e.g., 'csv_source', 'searchable_csv', 'json', 'md')
#' @return String representing the full URL to access the specified resource
generate_href <- function(filter, table_details, href_type) {
  # Loading the correct href details from the CONFIG 
  href_details <- CONFIG$HREF_DETAILS[[href_type]]
  
  base_url <- href_details$base_url
  # For the original register
  if (filter == "none") {
    return(paste0(base_url, "register", href_details$ext))
  } 

  # Determining if we need to include "/docs" in the href for csvs.
  # This is needed for the case where we have filters
  include_docs_in_href <- href_type %in% c("csv_source", "searchable_csv")
  if (include_docs_in_href){
    base_url <- paste0(base_url, "docs/")
  } 

  # Setting href for filters with subcategories
  if ("subcat" %in% names(table_details)){
    return(paste0(base_url, filter, "/", table_details[["subcat"]], "/", table_details[["slug_name"]], "/register", href_details$ext))
  }

  # For filters without subcategories
  return(paste0(base_url, filter, "/", table_details[["slug_name"]], "/register", href_details$ext))
}

#' Creates index postfix, prefix and the header 
#'
#' @param output_dir The output directory of the section files
#' @param filter The filter name 
#' @param table_details List containing details such as the table name, subcat name.
create_index_section_files <- function(output_dir, filter, table_details) {
  create_index_postfix_html(output_dir, filter, table_details)
  create_index_prefix_html(output_dir)
  create_index_header_html(output_dir)
}

#' Renders html for a single table
#' 
#' This function can be used to render both register and non-register tables
#' @param table The table to render to HTML
#' @param table_details List containing details such as the table name, subcat name.
#' @param filter The filter
render_html <- function(table, table_details, filter){

  # Creating md file from which HTML file is made
  if (table_details[["is_reg_table"]]){
    render_register_md(table, table_details, filter)
  }

  else{
    render_non_register_md(table, table_details, filter)
  }

  output_dir <- table_details[["output_dir"]]
  temp_md_file_path <- paste0(output_dir, "temp.md")

  # Creating the index section files and yml document
  create_index_section_files(output_dir, filter, table_details)
  generate_html_document_yml(output_dir)

  yaml_path <- normalizePath(file.path(getwd(), paste0(output_dir, "html_document.yml")))

  # Render HTML from markdown
  rmarkdown::render(
    input = temp_md_file_path,
    output_file = "index.html",
    output_dir = output_dir,
    output_yaml = yaml_path
  )

  file.remove(temp_md_file_path)

  # For all registered tables besides the original we change the html
  # file so that the path to the libs folder refers to the libs folder "docs/libs".
  # This is done to remove duplicates of "libs" folders.
  if (filter != "none"){
    html_file_path <- paste0(output_dir, "index.html")
    edit_html_lib_paths(html_file_path)
    # Deleting the libs folder after changing the html lib path
    unlink(paste0(output_dir, "/libs"), recursive = TRUE)
  }
}

#' Loads a html file and replaces the libs path in the html file to the libs folder in "docs/libs"
#' This is done so all html files can share one libs folder. 
#' 
#' @param html_file_path The path to the html file that needs to be edited.
edit_html_lib_paths <- function(html_file_path) {

  path_components <- strsplit(html_file_path, "/")[[1]]
  # The count of dirs one needs to move up to reach "docs" folder. "-2" is used because both "docs"
  # "index.html" are elements in path_components. 
  count_dir_up <- length(path_components) - 2
  up_dirs_string <- rep("../", count_dir_up)

  # Relative path to the "docs/libs" folder
  path_to_base <- paste0(up_dirs_string, collapse = "")
  relative_libs_dir <- paste0(path_to_base, "libs/")

  # Read the HTML file lines into a vector
  html_lines <- readLines(html_file_path)
  
  # Replace lines containing "=libs/" with the appropriate relative path to "docs/libs"
  edited_lines <- gsub('="libs/', paste0('="', relative_libs_dir), html_lines)
  
  # Write the edited lines back to the file
  writeLines(edited_lines, html_file_path)
}